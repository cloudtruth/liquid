"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[546],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,f=c["".concat(s,".").concat(u)]||c[u]||d[u]||o;return n?a.createElement(f,i(i({ref:t},m),{},{components:n})):a.createElement(f,i({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},166:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return m},default:function(){return c}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={},s="Custom Loaders",p={unversionedId:"guides/custom-loaders",id:"guides/custom-loaders",isDocsHomePage:!1,title:"Custom Loaders",description:"Loaders are responsible for finding a template's source text given a name or identifier. Built-in",source:"@site/docs/guides/custom-loaders.md",sourceDirName:"guides",slug:"/guides/custom-loaders",permalink:"/liquid/guides/custom-loaders",editUrl:"https://github.com/jg-rp/liquid/tree/gh-pages/docs/docs/guides/custom-loaders.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Custom Tags",permalink:"/liquid/guides/custom-tags"},next:{title:"Custom Template Cache",permalink:"/liquid/guides/custom-template-cache"}},m=[{value:"Front Matter Loader",id:"front-matter-loader",children:[],level:2},{value:"Async Database Loader",id:"async-database-loader",children:[],level:2},{value:"File Extension Loader",id:"file-extension-loader",children:[],level:2}],d={toc:m};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"custom-loaders"},"Custom Loaders"),(0,o.kt)("p",null,"Loaders are responsible for finding a template's source text given a name or identifier. Built-in\nloaders include a ",(0,o.kt)("a",{parentName:"p",href:"../api/filesystemloader"},"FileSystemLoader"),", a ",(0,o.kt)("a",{parentName:"p",href:"../api/choiceloader"},"ChoiceLoader"),"\nand a ",(0,o.kt)("a",{parentName:"p",href:"../api/dictloader"},"DictLoader"),". You might want to write a custom loader to load templates\nfrom a database or add extra meta data to the template context, for example."),(0,o.kt)("p",null,"Write a custom loader class by inheriting from ",(0,o.kt)("inlineCode",{parentName:"p"},"liquid.loaders.BaseLoader")," and implementing its\n",(0,o.kt)("inlineCode",{parentName:"p"},"get_source")," method. Then pass an instance of your loader to a ",(0,o.kt)("a",{parentName:"p",href:"../api/Environment"},"liquid.Environment"),"\nas the ",(0,o.kt)("inlineCode",{parentName:"p"},"loader")," argument."),(0,o.kt)("p",null,"We could implement our own version of ",(0,o.kt)("inlineCode",{parentName:"p"},"DictLoader")," like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="myloaders.py"',title:'"myloaders.py"'},"from typing import TYPE_CHECKING\nfrom typing import Dict\n\nfrom liquid.loaders import BaseLoader\nfrom liquid.loaders import TemplateSource\nfrom liquid.exceptions import TemplateNotFound\n\nif TYPE_CHECKING:\n    from liquid import Environment\n\nclass DictLoader(BaseLoader):\n    def __init__(self, templates: Dict[str, str]):\n        self.templates = templates\n\n    def get_source(self, _: Environment, template_name: str) -> TemplateSource:\n        try:\n            source = self.templates[template_name]\n        except KeyError as err:\n            raise TemplateNotFound(template_name) from err\n\n        return TemplateSource(source, template_name, None)\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSource")," is a named tuple containing the template source as a string, its name and an\noptional ",(0,o.kt)("inlineCode",{parentName:"p"},"uptodate")," callable. If ",(0,o.kt)("inlineCode",{parentName:"p"},"uptodate")," is not ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," it should be a callable that returns\n",(0,o.kt)("inlineCode",{parentName:"p"},"False")," if the template needs to be loaded again, or ",(0,o.kt)("inlineCode",{parentName:"p"},"True")," otherwise."),(0,o.kt)("p",null,"You could then use ",(0,o.kt)("inlineCode",{parentName:"p"},"DictLoader")," like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from liquid import Environment\nfrom myloaders import DictLoader\n\nsnippets = {\n    "greeting": "Hello {{ user.name }}",\n    "row": """\n        <div class="row"\'\n            <div class="col">\n            {{ row_content }}\n            </div>\n        </div>\n        """,\n}\n\nenv = Environment(loader=DictLoader(snippets))\n\ntemplate = env.from_string("""\n    <html>\n        {% include \'greeting\' %}\n        {% for i in (1..3) %}\n        {% include \'row\' with i as row_content %}\n        {% endfor %}\n    </html>\n""")\n\nprint(template.render(user={"name": "Brian"}))\n')),(0,o.kt)("h2",{id:"front-matter-loader"},"Front Matter Loader"),(0,o.kt)("p",null,"Loaders can add to a template's render context using the ",(0,o.kt)("inlineCode",{parentName:"p"},"matter")," argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSource"),". This\nexample implements a Jekyll style front matter loader."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import re\nimport yaml  # Assumes pyyaml is installed\n\nfrom liquid import Environment\nfrom liquid.loaders import FileSystemLoader\nfrom liquid.loaders import TemplateSource\n\nRE_FRONT_MATTER = re.compile(r"\\s*---\\s*(.*?)\\s*---\\s*", re.MULTILINE | re.DOTALL)\n\n\nclass FrontMatterFileSystemLoader(FileSystemLoader):\n    def get_source(\n        self,\n        env: Environment,\n        template_name: str,\n    ) -> TemplateSource:\n        source, filename, uptodate, matter = super().get_source(env, template_name)\n        match = RE_FRONT_MATTER.search(source)\n\n        if match:\n            # Should add some yaml error handling here.\n            matter = yaml.load(match.group(1), Loader=yaml.Loader)\n            source = source[match.end() :]\n\n        return TemplateSource(\n            source,\n            filename,\n            uptodate,\n            matter,\n        )\n')),(0,o.kt)("h2",{id:"async-database-loader"},"Async Database Loader"),(0,o.kt)("p",null,"Template loaders can implement ",(0,o.kt)("inlineCode",{parentName:"p"},"get_source_async"),". When a template is rendered by awaiting\n",(0,o.kt)("inlineCode",{parentName:"p"},"render_async")," instead of calling ",(0,o.kt)("inlineCode",{parentName:"p"},"render"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"{% render %}")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"{% include %}")," tags will use\n",(0,o.kt)("inlineCode",{parentName:"p"},"get_template_async")," of the bound ",(0,o.kt)("inlineCode",{parentName:"p"},"Environment"),", which delegates to ",(0,o.kt)("inlineCode",{parentName:"p"},"get_source_async")," of the\nconfigured loader."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"AsyncDatabaseLoader")," will load templates from a PostgreSQL database using\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/MagicStack/asyncpg"},"asyncpg"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import datetime\nimport functools\n\nimport asyncpg\n\nfrom liquid import Environment\nfrom liquid.exceptions import TemplateNotFound\nfrom liquid.loaders import BaseLoader\nfrom liquid.loaders import TemplateSource\n\n\nclass AsyncDatabaseLoader(BaseLoader):\n    def __init__(self, pool: asyncpg.Pool) -> None:\n        self.pool = pool\n\n    def get_source(self, env: Environment, template_name: str) -> TemplateSource:\n        raise NotImplementedError("async only loader")\n\n    async def _is_up_to_date(self, name: str, updated: datetime.datetime) -> bool:\n        async with self.pool.acquire() as connection:\n            return updated == await connection.fetchval(\n                "SELECT updated FROM templates WHERE name = $1", name\n            )\n\n    async def get_source_async(\n        self, env: Environment, template_name: str\n    ) -> TemplateSource:\n        async with self.pool.acquire() as connection:\n            source = await connection.fetchrow(\n                "SELECT source, updated FROM templates WHERE name = $1", template_name\n            )\n\n        if not source:\n            raise TemplateNotFound(template_name)\n\n        return TemplateSource(\n            source=source["source"],\n            filename=template_name,\n            uptodate=functools.partial(\n                self._is_up_to_date, name=template_name, updated=source["updated"]\n            ),\n        )\n')),(0,o.kt)("h2",{id:"file-extension-loader"},"File Extension Loader"),(0,o.kt)("p",null,"This example extends ",(0,o.kt)("inlineCode",{parentName:"p"},"FileSystemLoader")," to automatically append a file extension if one is\nmissing."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from pathlib import Path\n\nfrom typing import Union\nfrom typing import Iterable\n\nfrom liquid.loaders import FileSystemLoader\n\n\nclass FileExtensionLoader(FileSystemLoader):\n    """A file system loader that adds a file name extension if one is missing."""\n\n    def __init__(\n        self,\n        search_path: Union[str, Path, Iterable[Union[str, Path]]],\n        encoding: str = "utf-8",\n        ext: str = ".liquid",\n    ):\n        super().__init__(search_path, encoding=encoding)\n        self.ext = ext\n\n    def resolve_path(self, template_name: str) -> Path:\n        template_path = Path(template_name)\n\n        if not template_path.suffix:\n            template_path = template_path.with_suffix(self.ext)\n\n        # Don\'t allow "../" to escape the search path.\n        if os.path.pardir in template_path.parts:\n            raise TemplateNotFound(template_name)\n\n        for path in self.search_path:\n            source_path = path.joinpath(template_path)\n\n            if not source_path.exists():\n                continue\n            return source_path\n        raise TemplateNotFound(template_name)\n')))}c.isMDXComponent=!0}}]);